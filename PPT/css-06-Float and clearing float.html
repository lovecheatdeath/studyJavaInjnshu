<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>葡萄藤PPT</title>
  <link rel="stylesheet" href="../css/reveal/reveal.css">
  <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
  <link rel="stylesheet" href="../css/reveal/theme/ptt.css">
  <!-- syntax highlighting 代码高亮主题 -->
  <link rel="stylesheet" href="../lib/reveal/css/zenburn.css">
  <!-- 打印和PDF输出样式 -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? '../css/reveal/print/pdf.css' : '../css/reveal/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <style>
    .mycontent {
      padding: 15px 20px!important;
      text-align: left!important;
      color:#333!important;
    }
    p {text-align: left!important;}
    .wrap {
      width: 1000px;
      margin: 30px auto 5px!important;
      border: 3px solid blue!important;
      background: #f5f5f5;
    }
    .left {
      float: left;
    }
    .clear {
      clear: both;
    }
    .main {
      width: 50%;
      height: 60px;
      background: #ffe3d7;
    }
    .side {
      width: 20%;
      background: lightblue;
    }
    .footer {
      width: 1000px;
      margin: 5px auto 30px!important;
      background: #eee;
      border: 3px solid #ccc!important;
    }
    .clearfix ｛｝
    .clearfix:before, .clearfix:after {
      display: table;
      content: " ";
    }
    .clearfix:after {
      height: 0;
      clear: both;
    }
  </style>
</head>
<body>
<img src="../img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
<map name="pttmap">
  <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com" alt="" target="_blank"/>
</map>
<div class="reveal">
  <div class="slides">
    <section>
      <h2>【CSS-task6】什么是浮动？有哪些清除浮动的方法？</h2>
      <h3>小课堂【郑州第19期】</h3>
      <h4>分享人：胡嘉杰</h4>
    </section>
    <section>
      <h3>1.什么是浮动？</h3>
    </section>
    <section>
      <p>float即为浮动，在CSS中的作用是使元素脱离正常的文档流并使其移动到其父元素的“最左边”或“最右边”。</p>
    </section>
    <section>
      <p>文档流：在html中文档流即为元素从上至下排列的顺序。</p>
      <p>脱离文档流：元素从正常的排列顺序被抽离。</p>
      <p>最左边/最右边：上述的移动到父元素最左和最右是指元素往左或往右移动直到碰到另一个浮动元素或父元素内容区的边界（不包括padding）。</p>
    </section>
    <section>
      <h3>2.为何要清除浮动？</h3>
      <p>要解答这个问题，我们得先说说CSS中的定位机制：普通流，浮动。</p>
    </section>
    <section>
      <p>1）普通流：很多人或者文章称之为文档流或者普通文档流，其实标准里根本就没有这个词。如果把文档流直译为英文就是 document flow ，
        但标准里只有另一个词，叫做 普通流（normal flow)，或者称之为常规流。但似乎大家更习惯文档流的称呼，因为很多中文翻译的书就是这么来的。
        比如《CSS Mastery》，英文原书中至始至终都只有普通流 normal flow（普通流） 这一词，从来没出现过document flow（文档流）
      </p>
    </section>
    <section>
      <p>2）浮动：浮动的框可以左右移动，直至它的外边缘遇到包含框或者另一个浮动框的边缘。浮动框不属于文档中的普通流，
        当一个元素浮动之后，不会影响到 块级框的布局而只会影响内联框（通常是文本）的排列，文档中的普通流就会表现得和浮动框不存在一样，
        当浮动框高度超出包含框的时候，也就会出现包含框不会 自动伸高来闭合浮动元素（“高度塌陷”现象）。顾名思义，就是漂浮于普通流之上，
        像浮云一样，但是只能左右浮动。
      </p>
    </section>
    <section>
      <p>
        正是因为浮动的这种特性，导致本属于普通流中的元素浮动之后，包含框内部由于不存在其他普通流元素了，也就表现出高度为0（高度塌陷）。
        在实际布局中，往往这并不是我们所希望的，所以需要<strong>闭合</strong>浮动元素，使其包含框表现出正常的高度。
      </p>
    </section>
    <section>
      <h4>
        清除浮动 还是 闭合浮动 （Enclosing float or Clearing float）？
      </h4>
      <p>很多人都已经习惯称之为清除浮动，但是确切地来说是不准确的。</p>
      <p>1）清除浮动：清除对应的单词是 clear，对应CSS中的属性是 clear：left | right | both | none；</p>
      <p>2）闭合浮动：更确切的含义是使浮动元素闭合，从而减少浮动带来的影响。</p>
    </section>
    <section>
      <div class="wrap mycontent">
        <div class="main left mycontent">.main：很抱歉，现代浏览器中我没能把wrap撑高(float:left)</div>
        <div class="side left mycontent">.side：我也浮动了(float:left)</div>
      </div>
      <div class="footer clear mycontent">.footer：我通过设置 clear:both <strong>清除浮动</strong>,虽然位置正确了,但是 wrap 的高度没变,有些不爽</div>
      <div class="wrap clearfix mycontent">
        <div class="main left mycontent">.main：wrap自己闭合浮动了，所以footer不用再清除浮动了(float:left)</div>
        <div class="side left mycontent">.side：我也浮动了(float:left)</div>
      </div>
      <div class="footer mycontent">.footer：这次 wrap 人品爆发了, 通过 .clearfix 已经<strong>闭合浮动</strong>了</div>
    </section>
    <section>
      <p>通过以上实例发现，其实我们想要达到的效果更确切地说是闭合浮动，而不是单纯的清除浮动，在footer上设置clear：both清除浮动并不能解决wrap高度塌陷的问题。</p>
    </section>
    <section>
      <h3>3.有哪些清除浮动的方法？</h3>
    </section>
    <section>
      <p>1）父级div定义 height </p>
      <p>原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题。</p>
      <p>优点：简单、代码少、容易掌握</p>
      <p>缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题</p>
      <p>建议：不推荐使用，只建议高度固定的布局时使用</p>
    </section>
    <section>
      <p>2）添加额外标签</p>
      <p>原理：添加一个空div，通过在浮动元素末尾添加一个空的标签例如 div style="clear:both" ，其他标签br等亦可，让父级div能自动获取到高度</p>
      <p>优点：通俗易懂，容易掌握</p>
      <p>缺点：可以想象通过此方法，会添加多少无意义的空标签，有违结构与表现的分离，在后期维护中将是噩梦，这是坚决不能忍受的，所以你看了这篇文章之后还是建议不要用了吧</p>
      <p>建议：不推荐使用，但此方法是以前主要使用的一种清除浮动方法。</p>
    </section>
    <section>
      <p>3）父元素设置 overflow：hidden</p>
      <p>原理：必须定义width，在IE6中还需要触发 hasLayout ，例如 zoom：1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度</p>
      <p>优点：不存在结构和语义化问题，代码量极少</p>
      <p>缺点：内容增多时候容易造成不会自动换行导致内容被隐藏掉，不能和position配合使用，无法显示需要溢出的元素；04年POPO就发现overflow:hidden会导致IE中中键失效，按鼠标中键时，那个上下滚屏箭头不会出现</p>
      <p>建议：只推荐没有使用position或对overflow:hidden理解比较深的朋友使用。</p>
    </section>
    <section>
      <p>4）使用:after 伪元素</p>
      <p>原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。需要注意的是 :after是伪元素，不是伪类</p>
      <div class="mycontent">
        .clearfix:after {content:" "; display:block; height:0; visibility:hidden; clear:both; }<br>
        .clearfix { *zoom:1; }
      </div>
      <p>优点：结构和语义化完全正确,代码量居中。浏览器支持好、不容易出现怪问题（bootstrap用的也是这种方法）</p>
      <p>缺点：复用方式不当会造成代码量增加，初学者不理解原理，要两句代码结合使用才能让主流浏览器都支持。</p>
      <p>建议：推荐使用，建议定义公共类，以减少CSS代码。</p>
    </section>
    <section>
      <p>5）父元素设置 overflow：auto 属性</p>
      <p>原理：必须定义width或zoom:1，同时不能定义height，使用overflow:auto时，浏览器会自动检查浮动区域的高度</p>
      <p>优点：不存在结构和语义化问题，代码量极少</p>
      <p>缺点：多个嵌套后，firefox某些情况会造成内容全选；IE中 mouseover 造成宽度改变时会出现最外层模块有滚动条等，firefox早期版本会无故产生focus等</p>
      <p>建议：不推荐使用，如果你需要出现滚动条或者确保你的代码不会出现滚动条就使用吧。</p>
    </section>
    <section>
      <p>6）父元素也设置浮动</p>
      <p>原理：所有代码一起浮动，就变成了一个整体</p>
      <p>优点：不存在结构和语义化问题，代码量极少</p>
      <p>缺点：使得与父元素相邻的元素的布局会受到影响，不可能一直浮动到body</p>
      <p>建议：不推荐使用，只作了解。</p>
    </section>
    <section>
      <p>7）父元素设置display:table</p>
      <p>原理：将div属性变成表格</p>
      <p>优点：结构语义化完全正确，代码量极少</p>
      <p>缺点：盒模型属性已经改变，由此造成的一系列问题，得不偿失</p>
      <p>建议：不推荐使用，只作了解</p>
    </section>
    <section>
      <h4>小结</h4>
      <p>通过对比，我们不难发现，其实以上列举的方法，无非有两类：</p>
      <p>其一，通过在浮动元素的末尾添加一个空元素，设置 clear：both属性，after伪元素其实也是通过 content 在元素的后面生成了内容为一个空格的table元素；</p>
      <p>其二，通过设置父元素 overflow 或者display：table 属性来闭合浮动，我们来探讨一下这里面的原理。</p>
    </section>
    <section>
      <p>在CSS2.1里面有一个很重要的概念，但是国内的技术博客介绍到的比较少，那就是 Block formatting contexts （块级格式化上下文），以下简称 BFC。</p>
      <p>CSS3里面对这个规范做了改动，称之为：flow root，并且对触发条件进行了进一步说明。</p>
    </section>
    <section>
      <h4>那么如何触发BFC呢？</h4>
      <p>float 除了none以外的值</p>
      <p>overflow 除了visible 以外的值（hidden，auto，scroll ）</p>
      <p>display (table-cell，table-caption，inline-block) </p>
      <p>position（absolute，fixed）</p>
      <p>fieldset元素</p>
    </section>
    <section>
      <p>BFC的特性：</p>
      <p>1)块级格式化上下文会阻止外边距叠加</p>
      <p>当两个相邻的块框在同一个块级格式化上下文中时，它们之间垂直方向的外边距会发生叠加。换句话说，如果这两个相邻的块框不属于同一个块级格式化上下文，那么它们的外边距就不会叠加。</p>
      <p>2)块级格式化上下文不会重叠浮动元素</p>
      <p>
        根据规定，一个块级格式化上下文的边框不能和它里面的元素的外边距重叠。这就意味着浏览器将会给块级格式化上下文创建隐式的外边距来阻止它和浮动元素的外边距叠加。
        由于这个原因，当给一个挨着浮动的块级格式化上下文添加负的外边距时将会不起作用
      </p>
    </section>
    <section>
      <p>通俗地来说：创建了 BFC的元素就是一个独立的盒子，里面的子元素不会在布局上影响外面的元素，反之亦然，同时BFC任然属于文档中的普通流。</p>
      <p>至此，您或许明白了为什么 overflow:hidden或者auto可以闭合浮动了，真是因为父元素创建了新的BFC。</p>
    </section>
    <section>
      <p>上面已经列举了7种闭合浮动的方法，从各个方面比较，after伪元素闭合浮动无疑是相对比较好的解决方案了，下面详细说说该方法。</p>
      <div class="mycontent">
        .clearfix:after {content:" "; display:block; height:0; visibility:hidden; clear:both; }<br>
        .clearfix { *zoom:1; }
      </div>
      <p>1) display:block 使生成的元素以块级元素显示,占满剩余空间;</p>
      <p>2) height:0 避免生成内容破坏原有布局的高度。</p>
      <p>3) visibility:hidden 使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互;</p>
    </section>
    <section>
      <p>4）通过 content:" "生成内容作为最后一个元素，至于content里面是空格还是其他都是可以的，
        例如oocss里面就有经典的 content:"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
        有些版本可能content 里面内容为空,我是不推荐这样做的,firefox直到7.0 content:"" 仍然会产生额外的空隙；</p>
      <p>5）zoom：1 触发IE hasLayout。通过分析发现，除了clear：both用来闭合浮动的，其他代码无非都是为了隐藏掉content生成的内容，
        这也就是其他版本的闭合浮动为什么会有font-size：0，line-height：0。</p>
    </section>
    <section>
      <h3>4.精益求精</h3>
    </section>
    <section>
      <h4>方案一：</h4>
      <p>相对于空标签闭合浮动的方法代码似乎还是有些冗余，通过查询发现Unicode字符里有一个“零宽度空格”，也就是U+200B ，这个字符本身是不可见的，所以我们完全可以省略掉 visibility:hidden了</p>
      <div class="mycontent">
        .clearfix:after {content:"200B"; display:block; height:0; clear:both; }<br>
        .clearfix { *zoom:1; }.
      </div>
    </section>
    <section>
      <h4>方案二：</h4>
      <p>由Nicolas Gallagher 大湿提出来的,原文:<a href="//nicolasgallagher.com/micro-clearfix-hack/">A new micro clearfix hack</a> ，该方法也不存在firefox中空隙的问题。</p>
      <div class="mycontent">
        /* For modern browsers */<br>
        .clearfix:before,<br>
        .clearfix:after {<br>
        &nbsp;&nbsp; &nbsp;content: " ";<br>
        &nbsp;&nbsp; &nbsp;display: table;<br>
        }<br>
        .clearfix:after { clear: both; } /* For IE 6/7 (trigger hasLayout) */<br>
        .clearfix { zoom: 1; }<br>
      </div>
    </section>
    <section>
      <h4>需要注意的是：</h4>
      <p>上面的方法用到了 :before伪元素，很多人对这个有些迷惑，到底我什么时候需要用before呢？为什么方案一没有呢？</p>
      <p>其实它是用来处理margin边距重叠的，由于内部元素 float 创建了BFC，导致内部元素的margin-top和 上一个盒子的margin-bottom 发生叠加。
        如果这不是你所希望的，那么就可以加上before，如果只是单纯的闭合浮动，after就够了！</p>
    </section>
    <section>
      <p>
        在实际开发中，改进方案一由于存在Unicode字符不适合内嵌CSS的GB2312编码的页面，使用:after伪元素完全可以解决我们的需求了，
        改进方案二等待大家的进一步实践。方案3、5通过overflow闭合浮动，实际上已经创建了新的块级格式化上下文，
        这将导致其布局和相对于浮动的行为等发生一系列的变化，闭合浮动只不过是一系列变化中的一个作用而已。
        所以为了闭合浮动去改变全局特性，这是不明智的，带来的风险就是一系列的bug，比如firefox 早期版本产生 focus，截断绝对定位的层等等。
        始终要明白，如果单单只是需要闭合浮动，overflow就不要使用，而不是某些文章所说的“慎用”。
      </p>
    </section>
    <section>
      <p>参考一：<a href="//www.iyunlu.com/view/css-xhtml/55.html">那些年我们一起清除过的浮动</a></p>
      <p>参考二：<a href="//www.alixixi.com/web/a/2013092591109.shtml">float是什么？浮动在CSS中的作用</a></p>
    </section>
    <section>
      <h4>鸣谢</h4>
      <h4>感谢大家观看</h4>
      <h4><small>BY : 胡嘉杰 </small></h4>
    </section>

  </div>
</div>

<script src="../lib/reveal/js/head.min.js"></script>
<script src="../lib/reveal/reveal.js"></script>

<script>
  // 以下为常见配置属性的默认值
  // {
  // 	controls: true, // 是否在右下角展示控制条
  // 	progress: true, // 是否显示演示的进度条
  // 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
  // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
  // 	keyboard: true, // 是否启用键盘快捷键来导航
  // 	overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
  // 	center: true, // 是否将幻灯片垂直居中
  // 	touch: true, // 是否在触屏设备上启用触摸滑动切换
  // 	loop: false, // 是否循环演示
  // 	rtl: false, // 是否将演示的方向变成RTL，即从右往左
  // 	fragments: true, // 全局开启和关闭碎片。
  // 	autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
  // 	transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
  // 	transitionSpeed: 'default', // 过渡速度，default/fast/slow
  // 	mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
  // }
  // 初始化幻灯片
  Reveal.initialize({
    history: true,
    dependencies: [
      { src: '../plugin/markdown/marked.js' },
      { src: '../plugin/markdown/markdown.js' },
      { src: '../plugin/notes/notes.js', async: true },
      { src: '../plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
    ]
  });
</script>
</body>
</html>
