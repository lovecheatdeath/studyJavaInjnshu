<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>葡萄藤PPT</title>

    <link rel="stylesheet" href="../css/reveal/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="../css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="../lib/reveal/css/zenburn.css">

    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? '../css/reveal/print/pdf.css' : '../css/reveal/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
    <style>
        div {
            text-align: left;
        }
    </style>
</head>

<body>
    <img src="../img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
    <map name="pttmap">
    <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com" alt="" target="_blank"/>
</map>
    <div class="reveal">
        <div class="slides">
            <section>
                <h2>【CSS-task3】那种规范才是最好的规范？</h2>
                <h3>小课堂【武汉第177期】</h3>
                <p>分享人：庄引</p>
            </section>
            <section>
                <p>目录</p>
                <p>1.背景介绍</p>
                <p>2.知识剖析</p>
                <p>3.常见问题</p>
                <p>4.解决方案</p>
                <p>5.编码实战</p>
                <p>6.扩展思考</p>
                <p>7.参考文献</p>
                <p>8.更多讨论</p>
            </section>

            <section>
                <section>
                    <h3>1.背景介绍</h3>
                </section>
                <section>
                    <div>前端开发web应用的规范的作用两方面： 1) 代码一致性 2) 最佳实践。 通过保持代码风格一致，容易被理解和被维护。我们可以减少遗留系统维护的负担，并降低未来系统崩溃的风险。而通过遵照最佳实践，我们能确保优化的页面加载、性能以及可维护的代码。</div>
                </section>
            </section>


            <section>
                <section>
                    <h3>2.知识剖析</h3>
                </section>
                <section>
                    <h3>基本准则</h3>
                    <div>
                        代码规范体现了一个coder和团队的专业程度 团队的愿景：成为业界卓越的Web团队！坚持制定好的代码规范。 无论团队人数多少，代码应该同 一人。
                    </div>
                </section>
                <section>
                    <h3>代码风格</h3>
                </section>
                <section>
                    <h3>2.1 文件</h3>
                    <div> [建议] CSS 文件使用无 BOM 的 UTF-8 编码。 解释： UTF-8 编码具有更广泛的适应性。BOM 在使用程序或工具处理文件时可能造成不必要的干扰。</div>
                </section>
                <section>
                    <h3>2.2 缩进</h3>
                    <div>2.2 缩进 [强制] 使用 4 个空格做为一个缩进层级，不允许使用 2 个空格 或 tab 字符。 示例：
                        <pre><code>
                    .selector {
                        margin: 0; padding: 0;
                    }
                    </code></pre>
                    </div>
                </section>
                <section>
                    <h3>2.3 空格</h3>
                    <div>
                        [强制] 选择器 与 { 之间必须包含空格。 示例：
                        <pre><code>
                            .selector { }
                        </code></pre> [强制] 属性名 与之后的 : 之间不允许包含空格， : 与 属性值 之间必须包含空格。 示例：
                        <pre>
                            <code>
                                margin: 0;
                            </code>
                        </pre> [强制] 列表型属性值 书写在单行时，, 后必须跟一个空格。 示例：
                        <pre>
                        <code>
                            font-family: Arial, sans-serif;
                        </code>
                    </pre>
                    </div>
                </section>
                <section>
                    <h3>2.4 行长度</h3>
                    <div>
                        [强制] 每行不得超过 120 个字符，除非单行不可分割。 解释： 常见不可分割的场景为URL超长。 [建议] 对于超长的样式，在样式值的 空格 处或 , 后换行，建议按逻辑分组。 示例：
                    </div>
                </section>
                <section>
                    <pre>
                        <code>
/* 不同属性值按逻辑分组 */
background:
    transparent url(aVeryVeryVeryLongUrlIsPlacedHere)
    no-repeat 0 0;

/* 可重复多次的属性，每次重复一行 */
background-image:
    url(aVeryVeryVeryLongUrlIsPlacedHere)
    url(anotherVeryVeryVeryLongUrlIsPlacedHere);

/* 类似函数的属性值可以根据函数调用的缩进进行 */
background-image: -webkit-gradient(
    linear,
    left bottom,
    left top,
    color-stop(0.04, rgb(88,94,124)),
    color-stop(0.52, rgb(115,123,162))
);
                    </code>
                    </pre>
                </section>
                <section>
                    <h3>2.5 选择器</h3>
                    <div>
                        [强制] 当一个 rule 包含多个 selector 时，每个选择器声明必须独占一行。 示例：
                        <pre><code>
        /* good */
        .post,
        .page,
        .comment {
            line-height: 1.5;
        }

        /* bad */
        .post, .page, .comment {
            line-height: 1.5;
        }
    </code></pre>
                    </div>

                </section>
                <section>
                    <h3>2.6 属性</h3>
                    <div>


                        [强制] 属性定义必须另起一行。 示例：
                        <pre><code>
    /* good */
    .selector {
        margin: 0;
        padding: 0;
    }

    /* bad */
    .selector { margin: 0; padding: 0; }
</code></pre> [强制] 属性定义后必须以分号结尾。 示例：
                        <pre><code>
    /* good */
    .selector {
        margin: 0;
    }

    /* bad */
    .selector {
        margin: 0
    }
</code></pre>

                    </div>
                </section>
                <section>
                    <h2>通用</h2>
                </section>
                <section>
                    <h3>3.1 选择器</h3>
                    <div>


                        [强制] 如无必要，不得为 id、class 选择器添加类型选择器进行限定。 解释： 在性能和维护性上，都有一定的影响。 示例：
                        <pre><code>
    /* good */
    #error,
    .danger-message {
        font-color: #c00;
    }

    /* bad */
    dialog#error,
    p.danger-message {
        font-color: #c00;
    }
</code></pre>

                    </div>
                </section>
                <section>
                    <h3>3.2 属性缩写</h3>
                    <div>


                        [建议] 在可以使用缩写的情况下，尽量使用属性缩写。 示例：
                        <pre><code>
    /* good */
    .post {
        font: 12px/1.5 arial, sans-serif;
    }

    /* bad */
    .post {
        font-family: arial, sans-serif;
        font-size: 12px;
        line-height: 1.5;
    }
</code></pre>

                    </div>
                </section>
                <section>
                    <h3>3.3 属性书写顺序</h3>
                    <div>
                        [建议] 同一 rule set 下的属性在书写时，应按功能进行分组，并以 Formatting Model（布局方式、位置） > Box Model（尺寸） > Typographic（文本相关） > Visual（视觉效果） 的顺序书写，以提高代码的可读性。 解释： Formatting Model 相关属性包括：position / top / right / bottom / left / float / display / overflow 等 Box Model 相关属性包括：border
                        / margin / padding / width / height 等 Typographic 相关属性包括：font / line-height / text-align / word-wrap 等 Visual 相关属性包括：background / color / transition / list-style 等 另外，如果包含 content 属性，应放在最前面。 示例：


                    </div>
                </section>
                <section>
                    <pre><code>
    .sidebar {
        /* formatting model: positioning schemes / offsets / z-indexes / display / ...  */
        position: absolute;
        top: 50px;
        left: 0;
        overflow-x: hidden;

        /* box model: sizes / margins / paddings / borders / ...  */
        width: 200px;
        padding: 5px;
        border: 1px solid #ddd;

        /* typographic: font / aligns / text styles / ... */
        font-size: 14px;
        line-height: 20px;

        /* visual: colors / shadows / gradients / ... */
        background: #f5f5f5;
        color: #333;
        -webkit-transition: color 1s;
           -moz-transition: color 1s;
                transition: color 1s;
    }
</code></pre>
                </section>
                <section>
                    <h3>3.4 清除浮动</h3>
                    <div>
                        [建议] 当元素需要撑起高度以包含内部的浮动元素时，通过对伪类设置 clear 或触发 BFC 的方式进行 clearfix。尽量不使用增加空标签的方式。 解释： 触发 BFC 的方式很多，常见的有：
                        <p>
                            <ol>
                                <li>float 非 none</li>
                                <li>position 非 static</li>
                                <li>overflow 非 visible</li>
                            </ol>
                        </p>
                        注意，对已经触发 BFC 的元素不需要再进行 clearfix。
                    </div>
                </section>
                <section>
                    <h4>3.5 !important</h4>
                    <div>
                        [建议] 尽量不使用 !important 声明。 [建议] 当需要强制指定样式且不允许任何场景覆盖时，通过标签内联和 !important 定义样式。 解释： 必须注意的是，仅在设计上 确实不允许任何其它场景覆盖样式 时，才使用内联的 !important 样式。通常在第三方环境的应用中使用这种方案。下面的 z-index 章节是其中一个特殊场景的典型样例。
                    </div>
                </section>
            </section>
            <section>
                <section>
                    <h3>3.常见问题</h3>
                </section>
                <section>
                    <p>问题1:class命名有什么常用方式？</p>
                </section>
            </section>
            <section>
                <section>

                    <h3>4.解决方案</h3>
                </section>
                <section>
                    <p>在实际编程中，命名问题一直是很麻烦的问题，要想代码可读性高，维护方便，就必须规范命名。这里介绍几种命名方法</p>
                </section>
                <section>
                    <h4>原子类命名规则</h4>
                    <p>将复用性高的单条属性直接命名成类</p>
                    <pre>
                    <code>
                        .ml5{margin-left: 5px;}
                    </code>
                    </pre>
                </section>
                <section>
                    <h4>模块命名规则</h4>
                    <p>按照职能划分命名规则</p>
                    <p>例如，模块是nav，便可以命名nav-tittle、nav-left</p>
                </section>
                <section>
                    <h4>BEM</h4>
                    <p style="text-align: left;">BEM思想是由于项目开发中，每个组件都是唯一无二的，其名字也是独一无二的，组件内部元素的名字都加上组件名，并用元素的名字作为选择器，自然组件内的样式就不会与组件外的样式冲突了。这是通过组件名的唯一性来保证选择器的唯一性，从而保证样式不会污染到组件外。</p>
                    <p>BEM的命名规矩很容易记：block-name__element-name–modifier-name，也就是模块名 + 元素名 + 修饰器名</p>
                    <pre>
                        <code>
                            <div class="page-btn">
                                <button type="button" class="page-btn__prev">上一页</button>
                                <!-- ... -->
                                <button type="button" class="page-btn__next">下一页</button>
                            </div>
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <h3>5.编码实战</h3>
            </section>
            <section>
                <section>
                    <h3>6.扩展思考</h3>
                </section>
                <section>
                    <p>问题一:原子类的优劣？</p>
                    <p class="fragment">原子类在网上争议非常大，原子类简单方便，但是不宜维护，控制困难。原子类其实不是一种工具，而是一种编写 CSS 的思想，即：抽出高度复用的样式模块，独立成一个原子类，为对应的模块添加。但是不宜过度使用，负责就和直接添加style没有区别了，在涉及数值方面我的建议时不要使用原子类，否则修改起来超级麻烦，可以使用less、sass等代替</p>
                </section>
            </section>
            <section>
                <section>
                    <h3>7.参考文献</h3>
                </section>
                <section style="text-align: left;">
                    <p>参考一：<a href="https://www.zhihu.com/question/19586885" target="_blank">如何规范 CSS 的命名和书写？</a></p>
                    <p><a href="http://alloyteam.github.io/CodeGuide/">Code Guide by @AlloyTeam</a></p>
                    <p>参考三：<a href="https://github.com/ecomfe/spec/blob/master/README.md">编码规范</a></p>
                </section>
            </section>
            <section>
                <section>
                    <h3>8.更多讨论</h3>
                </section>
                <section>
                    <p>讨论点一:什么代码规范是好的规范？</p>
                </section>
            </section>
            <section>
                <h4>鸣谢:</h4>
                <p>感谢大家观看</p>
                <p><small>BY : 庄引</small></p>
            </section>

        </div>
    </div>

    <script src="../lib/reveal/js/head.min.js"></script>
    <script src="../lib/reveal/reveal.js"></script>

    <script>
        // 以下为常见配置属性的默认值
        // {
        // 	controls: true, // 是否在右下角展示控制条
        // 	progress: true, // 是否显示演示的进度条
        // 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
        // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
        // 	keyboard: true, // 是否启用键盘快捷键来导航
        // 	overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
        // 	center: true, // 是否将幻灯片垂直居中
        // 	touch: true, // 是否在触屏设备上启用触摸滑动切换
        // 	loop: false, // 是否循环演示
        // 	rtl: false, // 是否将演示的方向变成RTL，即从右往左
        // 	fragments: true, // 全局开启和关闭碎片。
        // 	autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
        // 	transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
        // 	transitionSpeed: 'default', // 过渡速度，default/fast/slow
        // 	mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
        // }
        // 初始化幻灯片
        Reveal.initialize({
            history: true,
            dependencies: [{
                    src: '../plugin/markdown/marked.js'
                },
                {
                    src: '../plugin/markdown/markdown.js'
                },
                {
                    src: '../plugin/notes/notes.js',
                    async: true
                },
                {
                    src: '../plugin/highlight/highlight.js',
                    async: true,
                    callback: function() {
                        hljs.initHighlightingOnLoad();
                    }
                }
            ]
        });
    </script>
</body>

</html>
 
