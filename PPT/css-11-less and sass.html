<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>葡萄藤PPT</title>

    <link rel="stylesheet" href="../css/reveal/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="../css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="../lib/reveal/css/zenburn.css">

    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? '../css/reveal/print/pdf.css' : '../css/reveal/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
</head>
<body>
<img src="../img/css-02-how%20to%20configure%20nginx/logo.png" alt="" usemap="#pttmap" class="base-logo">
<map name="pttmap">
    <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com" alt="" target="_blank"/>
</map>
<div class="reveal">
    <div class="slides">
        <section>
            <h2 style="text-align: left;">【css-11】sass、less的用法</h2>
            <h3>小课堂【郑州第76期】</h3>
            <p style="text-align: center;">分享人：董瑞</p>
        </section>
        <section>
            <p>目录</p>
            <p>1.背景介绍</p>
            <p>2.知识剖析</p>
            <p>3.常见问题</p>
            <p>4.解决方案</p>
            <p>5.编码实战</p>
            <p>6.扩展思考</p>
            <p>7.参考文献</p>
            <p>8.更多讨论</p>
        </section>
        <section>
            <h3>1.背景介绍</h3>
        </section>
        <section>
            <p style="text-align: left"><strong>导语：</strong>
                学过CSS的人都知道，它不是一种编程语言。
                你可以用它开发网页样式，但是没法用它编程。也就是说，
                CSS基本上是设计师的工具，不是程序员的工具。在程序员眼里，
                CSS是一件很麻烦的东西。它没有变量，也没有条件语句，
                只是一行行单纯的描述，写起来相当费事。<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                很自然地，有人就开始为CSS加入编程元素，
                这被叫做"CSS预处理器"（css preprocessor）。通俗来讲：
                “CSS预处理器用一种专门的编程语言，进行Web页面样式的设计，
                然后再编译成正常的CSS文件，以供项目使用。CSS预处理器为CSS增加一些编程的特性，
                无需考虑浏览器的兼容性问题”。
            </p>
        </section>
        <section>
            <h3>2.知识剖析</h3>
        </section>
        <section>
            <h3>2.1 &nbsp;&nbsp;&nbsp;&nbsp;LESS是什么？</h3>
        </section>
        <section>
            <p style="text-align: left">
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                根据维基百科上的介绍，其实 LESS 是 Alexis Sellier 受 SASS 的影响创建的开源项目。
                当时 SASS 采用了缩进作为分隔符来区分代码块，而不是 CSS 中广为使用的括号。
                为了让 CSS 现有用户使用起来更为方便，Alexis 开发了 LESS 并提供了类似的功能。
                在一开始，LESS 的解释器也同样是由 Ruby 编写，
                后来才转而采用了 JavaScript. LESS 代码既可以运行在客户端，也可以运行在服务器端。
                在客户端只要把 LESS 代码和相应的 JavaScript 解释器在同一页面引用即可；
                而在服务器端，LESS 可以运行在 Node.js 上，也可以运行在 Rhino 这样的
                JavaScript 引擎上。
            </p>
        </section>
        <section>
            <h3>2.2&nbsp;&nbsp;&nbsp;&nbsp;如何使用LESS？</h3>
        </section>
        <section>
            <p style="text-align: left">
                <strong>LESS语法</strong><br>
                LESS 做为 CSS 的一种形式的扩展，它并没有减少 CSS 的功能，
                而是在现有的 CSS 语法之上，添加了许多其它的功能，
                在语法方面，LESS与CSS较为接近，一个合法的CSS代码段本身也是一段合法的LESS代码段。
                LESS提供变量、嵌套、混合、操作符、函数等一般编程所需的抽象机制。<br><br>
                <strong> LESS 拥有四大特性：变量、混入、嵌套、函数。</strong><br>
            </p>
        </section>
        <section style="text-align: left;">
            <p>LESS 还拥有一些很有趣的特性有助于我们的开发，例如模式匹配、条件表达式、命名空间和作用域，以及 JavaScript 赋值等等。</p>
            具体参考：<br>
            <a href="https://www.ibm.com/developerworks/cn/web/1207_shenyi_lesscss/" target="_blank">LESS使用参考1</a><br>
            <a href="http://www.w3cplus.com/css/less" target="_blank">LESS使用参考2</a><br>
            <a href="http://less.bootcss.com/" target="_blank">LESS使用参考3</a><br><br>
            可以了解：<br>
            <a href="https://www.oschina.net/question/12_46118" target="_blank">值得参考的 10 个 LESS CSS 实例</a>
        </section>
        <section>
            <h3>2.3 SASS是什么？</h3>
        </section>
        <section>
            <p style="width: 105%">
                SASS是一种CSS的开发工具，提供了许多便利的写法，大大节省了设计者的时间，使得CSS的开发，变得简单和可维护。
            </p>
        </section>
        <section>
            <h3>2.4如何使用SASS？</h3>
            <p >更多用法见下面链接</p>
            <a href="http://www.w3cplus.com/css/an-introduction-to-less-and-comparison-to-sass.html" target="_blank">Less介绍及其与Sass的差异</a>
        </section>
        <section>
            <h3>3.常见问题</h3>
        </section>
        <section>
            <h3 style="letter-spacing: 2px">less和sass有什么区别？</h3>
        </section>
        <section>
            <h3>4.解决方案</h3>
        </section>
        <section>
            <h3>一、安装sass与less</h3>
            <p style="width: 105%">
                sass基于Ruby语言开发而成，
                因此安装sass前需要安装Ruby。<br><br>
                less 在服务器端最容易的安装方式就是通过 npm （node.js 的包管理器），
                在客户端使用“.less”（LESS源文件），
                只需要在官网载一个javascript脚本文件主“less.js”。
                他们都可以利用第三方软件编译成css文件。
            </p>
        </section>
        <section>
            <h3>二、变量</h3>
            <p>
                sass 是以$开头定义的变量，如：$mainColor: #963;<br><br>
                less 是以@开头定义的变量，如 @mainColor: #963;
            </p>
        </section>
        <section>
            <h3>三、作用域</h3>
            <p>
                sass 没有全局变量，满足就近原则，但是实际中可以将需要定义的全局属性放在base.scss 文件中。注意变量名重复；<br>
                less 中的作用域和其他程序语言中的作用域非常的相同，
                他首先会查找局部定义的变量，如果没有找到，
                会像冒泡一样，一级一级往下查找，直到根为止，
                同样上面的例子，我们来看看他在LESS下所起的变化。
            </p>
        </section>
        <section>
            <h3>四、混合（Mixins）</h3>
            <p>
                <strong>Sass的混合：</strong>sass样式中声明Mixins时需要使用“@mixin”，
                然后后面紧跟Mixins的名，他也可以定义参数，同时可以给这个参数设置一个默认值，
                但参数名是使用“$”符号开始，而且和参数值之间需要使用冒号（：）分开。
                在选择器调用定义好的Mixins需要使用“@include”，
                然后在其后紧跟你要调用的Mixins名。不过在Sass中还支持老的调用方法，
                就是使用加号“+”调用Mixins，在“+”后紧跟Mixins名。
            </p>
        </section>
        <section>
            <p>
                一起来看个简单的例子，比如说在你的Sass样式中定义了一个名叫“error”的Mixin，
                这个“error”设置了一个参数“$borderWidth”，在没特别定义外，
                这个参数的默认值设置为“2px”：
            </p>
            <pre>
                <code>
                    /*声明一个Mixin叫作“error”*/
                        @mixin error($borderWidth:2px){
                        border:$borderWidth solid #f00;
                      color: #f00;
                    }
                    /*调用error Mixins*/
                    .generic-error {
                      @include error();/*直接调用error mixins*/
                    }
                    .login-error {
                      @include error(5px);/*调用error mixins，并将参数$borderWidth的值重定义为5px*/
                    }
                </code>
            </pre>
        </section>
        <section>
            <p>
                <strong>less 的混合：</strong>在LESS中，混合是指将定义好的“ClassA”中引入另一个已经定义的“Class”，就像在当前的“Class”中增加一个属性一样。
                不过LESS样式中声明Mixins和Sass声明方法不一样，他更像CSS定义样式，在LESS可以将Mixins看成是一个类选择器，
                当然 Mixins也可以设置参数，并给参数设置默认值。不过设置参数的变量名是使用“@”开头，
                同样参数和默认参数值之间需要使用冒号（：）分隔开。
            </p>
        </section>
        <section>
            <p style="text-align: left;word-break: break-all">
                正如Sass混合的示例，同样在LESS样式中定义一个名叫“error”的Mixin，这个“error”设置了一个参数“@borderWidth”，
                在没有特别定义外，这个参数的默认值是“2px”：
            </p>
            <pre>
                <code>
                  /*声明一个Mixin叫作“error”*/
                    .error(@borderWidth:2px){
                      border:@borderWidth solid #f00;
                      color: #f00;
                    }
                    /*调用error Mixins*/
                    .generic-error {
                      .error();/*直接调用error mixins*/
                    }
                    .login-error {
                      .error(5px);/*调用error mixins，并将参数@borderWidth的值重定义为5px*/
                    }
                </code>
            </pre>
        </section>
        <section>
            <h3>五、嵌套</h3>
            <pre>
                <code>
                   /*sass里的嵌套*/
                    section {
                      margin:10px;
                      nav {
                        height:25px;
                        a {
                          color:#0982c1;
                          &:hover {
                            text-decoration:underline;
                          }
                        }
                      }
                    }
                </code>
            </pre>
        </section>
        <section>
        <h3>关于嵌套的规则</h3>
            <ul>
                <li>显而易见：嵌套层级越多，生成的css的选择器的层级就会越深。哦，那么，why？
                    这就涉及到css选择器的优化了。</li>
                <li>首先，我们要弄清楚浏览器是怎么识别我们的选择器的，具体原理不赘述，知道是“选择器从右到左的原则”；</li>
                <li>于是，选择器的最后一部分，也就是选择器的最右边部分，就是“关键选择器”，它将决定选择器的效率高低；</li>
                <li>那么我们要提高选择器效率，就首先要考虑关键选择器，结论“越是具体的关键选择器，其性能越高”</li>
            </ul>
        </section>
        <section>
            <ul>
                <li>这里找到一份steve souder大神排的一个顺序：</li>
                <li>ID选择器（#myid）</li>
                <li>类选择器（.myclassname）</li>
                <li>标签选择器（div,h1,p）</li>
                <li>相邻选择器（h1+p）</li>
                <li>子选择器（ul>li）</li>
                <li>后代选择器（li a）</li>
                <li>通配符选择器（*）</li>
                <li>属性选择器（a[rel="external"]）</li>
                <li>伪类选择器（a:hover,li:nth-child）</li>
            </ul>
        </section>
        <section>
            <h3>六、继承</h3>
            <pre>
                <code>
                    /*sass的继承：@extend*/
                    .block {
                      margin: 10px 5px;
                      padding: 2px;
                    }
                    p {
                      @extend .block;/*继承.block选择器下所有样式*/
                      border: 1px solid #eee;
                    }
                    ul,ol {
                      @extend .block; /*继承.block选择器下所有样式*/
                      color: #333;
                      text-transform: uppercase;
                    }
                    /*less的继承：类似于mixins*/
                    .block {
                      margin: 10px 5px;
                      padding: 2px;
                    }
                    p {
                      .block;/*继承.block选择器下所有样式*/
                      border: 1px solid #eee;
                    }
                    ul,ol {
                      .block; /*继承.block选择器下所有样式*/
                      color: #333;
                      text-transform: uppercase;
                    }
                </code>
            </pre>
        </section>
        <section>
            <h3>继承的优缺点</h3>
            <p>上面说不恰当使用@mixin会使代码臃肿，这里有一个解决方案：@extend是可以调用类的，于是我们只需要把@mixin rounded替换成.rounded，然后通过@extend调用.rounded就可以解决@mixin导致样式重复出现多次的问题，是不是很棒?</p>
            <p>霸特！@extend在sass中使用也是有风险的！</p>
        </section>
        <section>
            <p>比如.rounded样式是一个类啊，不是一个id啊，它可能被运用在多个地方或多个样式文件中，这样就出现了一个问题</p>
            <p>就是转译出来的代码除了你想要的，还有可能夹带私货！</p>
            <p>为啥？因为类名用在不同的地方，就被不同的容器包裹着，但是@extend它又不是你妈，又不知道你肚子里想的啥，于是它就把不同地方出现的这个类名都引入了进来~于是就多了一堆乱七八糟的东西~</p>
        </section>
        <section>
            <h3>%Placeholder</h3>
            <p>为什么坚持用%Placeholder而尽量减少使用Minxins！

                @include定义好的Mixins和CSS代码中复制、粘贴没什么不一样，它将会让你的css代码生成很多重复的代码，让你的文件变得越来越臃肿，减慢网页的响应速度！
                </p>

                <p>什么意思？意思就是，在你编写sass的时候引用Minxins确实让你的编写便轻松了，但是生成的css文件却更大了，这不是本末倒置了么。</p>

                <p>那么用什么，用%Placeholder！它会把你相同的代码自动合并，减少代码量</p>
        </section>
        <section>
            <h3>5.编码实战</h3>
        </section>
        <section>
            <h4>额外声明的小知识点</h4>
            <ul>
                <li>变量的应用</li>
                <li>连接符&的应用</li>
                <li>声明@charset"UTF-8"以及如何注释</li>
                <li>关于嵌套时的属性赋值</li>
            </ul>
        </section>
        <section>
            <h3>6.扩展思考</h3>
        </section>
        <section>
            <p>
                less和sass选哪个用？<br><br>
                <a href="https://www.zhihu.com/question/22285654" target="_blank">less和sass现状</a>
            </p>
        </section>
        <section>
            <h3>7.参考文献</h3>
        </section>
        <section style="text-align: left;margin-left: 30%">
            <p>参考一：<a
                    href="https://www.ibm.com/developerworks/cn/web/1207_shenyi_lesscss/"
                    target="_blank">
                初步认识LESS</a></p>
            <p>参考二：<a href="http://www.w3cplus.com/css/less"
                      target="_blank">CSS——LESS</a></p>
            <p>参考三：<a href="http://www.cnblogs.com/StephenJiang/p/4607100.html"
                      target="_blank">sass 与 less 的区别与学习</a></p>
            <p>参考四：<a href="http://less.bootcss.com/"
                      target="_blank">less</a></p>
            <p>参考五：<a href="http://blog.csdn.net/github_33261002/article/details/51636862"
                      target="_blank">Less和Sass</a></p>
            <p>参考六：<a href="http://www.w3cplus.com/css/an-introduction-to-less-and-comparison-to-sass.html"
                      target="_blank">Less介绍及其与Sass的差异</a></p>
            <p>参考七：<a href="http://www.w3cplus.com/sassguide/"
                      target="_blank">SASS入门</a></p>
        </section>
        <section>
            <h3>8.更多讨论</h3>
        </section>
        <section>
            <p style="letter-spacing: 5px">国内互联网前端用LESS的还是SASS的多一些？</p>
        </section>
        <section>
            <h4>感谢观看</h4>
            <p>
                <small>BY : 万维娜/董瑞</small>
            </p>
        </section>
    </div>
</div>

<script src="../lib/reveal/js/head.min.js"></script>
<script src="../lib/reveal/reveal.js"></script>

<script>
    // 以下为常见配置属性的默认值
    // {

    // 	controls: true, // 是否在右下角展示控制条
    // 	progress: true, // 是否显示演示的进度条
    // 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
    // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
    // 	keyboard: true, // 是否启用键盘快捷键来导航
    // 	overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
    // 	center: true, // 是否将幻灯片垂直居中
    // 	touch: true, // 是否在触屏设备上启用触摸滑动切换
    // 	loop: false, // 是否循环演示
    // 	rtl: false, // 是否将演示的方向变成RTL，即从右往左
    // 	fragments: true, // 全局开启和关闭碎片。
    // 	autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
    // 	transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
    // 	transitionSpeed: 'default', // 过渡速度，default/fast/slow
    // 	mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
    // }
    // 初始化幻灯片
    Reveal.initialize({
        history: true,
        dependencies: [
            { src: '../plugin/markdown/marked.js' },
            { src: '../plugin/markdown/markdown.js' },
            { src: '../plugin/notes/notes.js', async: true },
            { src: '../plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
    });
</script>
</body>
</html>
