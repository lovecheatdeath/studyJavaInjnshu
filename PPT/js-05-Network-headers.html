<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>葡萄藤PPT</title>

    <link rel="stylesheet" href="../css/reveal/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="../css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="../lib/reveal/css/zenburn.css">

    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? '../css/reveal/print/pdf.css' : '../css/reveal/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
</head>
<body>
<img src="../img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
<map name="pttmap">
    <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com" alt="" target="_blank"/>
</map>
<div class="reveal">
    <div class="slides">
        <section>
            <h3>network中的请求信息，headers中的每一项分别是什么意义?</h3>
            <h4>小课堂【武汉第159期】</h4>
            <p>分享人：朱芳山</p>
        </section>
        <section>
            <p>目录</p>
            <p>1.背景介绍</p>
            <p>2.知识剖析</p>
            <p>3.常见问题</p>
            <p>4.解决方案</p>
            <p>5.编码实战</p>
            <p>6.扩展思考</p>
            <p>7.参考文献</p>
            <p>8.更多讨论</p>
        </section>
        <section>
            <h3>1.背景介绍</h3>
        </section>
        <section>
            <p style="text-align: left">作为一个Web开发人员，日常中与我们开发相关的，就是Chrome的开发者工具。
                今天就是要简要说说Chrome的开发者工具中Network部分。
                Network标签页对于分析网站请求的网络情况、查看某一请求的请求头和响
                应头还有响应内容很有用，特别是在查看Ajax类请求的时候，非常有帮助。
            </p>
        </section>
        <section>
            <h3>2.知识剖析</h3>
        </section>
        <section>
            <section>
                <p>1.Network中的信息</p>
            </section>
            <section>
                <p style="text-align: left">如果能多了解一些chrome开发者工具调试技巧/功能对于平时开发很与帮助，
                    在实际项目中多使用这些功能，提升自己的工作效率。下面我们来看chrome开发者工
                    具Network面板功能</p>
            </section>
            <section>
                <img src="../img/js-05-Network-headers/img1.png" width="971" height="491">
                <p style="text-align: left;font-size: 22px;margin: 0">
                    1、Controls 控制Network的外观和功能。<br>
                    2、Filters 控制Requests Table具体显示哪些内容。<br>
                    3、Overview 显示获取到资源的时间轴信息。<br>
                    4、Requests Table 按资源获取的前后顺序显示所有获取到的资源信息，点击资源名可以查看该资源的详细信息。<br>
                    5、Summary 显示总的请求数、数据传输量、加载时间信息。
                </p>
            </section>
            <section>
                <p style="text-align: left">
                    network面板可以记录页面上的网络请求的详情信息，从发起网页页面请求Request后分析
                    HTTP请求后得到的各个请求资源信息（包括状态、资源类型、大小、所用时间、Request和Response等），可以根据这个进行网络性能优化。

                </p>
                <p style="text-align: left">
                    下面我们主要讲Requests Table这一块的内容，header中的信息就在这一块。
                </p>
            </section>
            <section>
                <h4>
                    名词解释
                </h4>
                <p style="text-align: left;font-size: 30px">
                    Name：资源名称，点击名称可以查看资源的详情情况，包括Headers、Preview、Response、Cookies、Timing<br>
                    Status(&Text)：针对该请求服务器返回的状态码及描述该状态码的简短信息<br>
                    Type: 该资源的类型<br>
                    Size: 资源的大小<br>
                    Time: Time就是从请求开始到接到最后一个字节所经历的时间；而Latency为请
                    求开始到接收第一个字节所经历的时间。此处的请求开始指的是该请求的状态从stalled（阻塞）状态开始。<br>
                    Timeline（waterfall）: 该列呈现出了每个请求从阻塞状态到完成请求所经历的阶段，和整个页面从加载到完成过程中其中
                    资源的加载流。<br>
                </p>
            </section>
            <section>
                <p style="text-align: left";>
                    Initator: 初始化该请求的对象或进程，有以下几种情况<br>
                    Parser： 请求由Chrome的HTML解析器时发起的。<br>
                    Redirect：请求是由HTTP页面重定向发起的。<br>
                    Script：请求是由Script脚本发起的。<br>
                    Other：请求是由其他进程发起的，比如用户点击一个链接跳转到另一个页面或者在地址栏输入URL地址。
                </p>
            </section>
            <section>
                <p style="font-size: 40px">headers中的信息</p>
                <p style="text-align: left">
                    General:常规信息
                </p>
                <p style="text-align: left">
                    1、Request URL:资源的请求url<br>
                    2、Request Method:HTTP方法<br>
                    3、Status Code:响应状态码<br>
                </p>
                    <h6 style="font-size: 30px;margin: 0;text-align: left">
                    200：(状态码) OK<br>
                    301：资源（网页等）被永久转移到其它URL<br>
                    401：访问资源的权限不够。<br>
                    403：没有权限访问资源。<br>
                    404：需要访问的资源不存在。<br>
                    405：需要访问的资源被禁止。<br>
                    500 - 内部服务器错误<br>
                    更多关于这方面的知识可以参见相关小课堂
                    </h6>
                <p style="text-align: left">4、Remote Address：请求的远程地址</p>
            </section>
            <section>
                <p style="text-align: left">5、Referrer Policy：</p>
                <p style="text-align: left">在页面引入图片、JS 等资源，或者从一个页面跳到另一个页面，都会产生新的 HTTP 请求，浏览器一般都会给这些请求头加上表示来源的 Referrer 字段。</p>
                <p style="text-align: left;font-size: 25px">新的 Referrer Policy 规定了五种 Referrer 策略：No Referrer、No Referrer When Downgrade、Origin Only、Origin When Cross-origin、和 Unsafe URL。</p>
                <p style="text-align: left; font-size: 20px">
                No Referrer：任何情况下都不发送 Referrer 信息<br>
                No Referrer When Downgrade：仅当发生协议降级（如 HTTPS 页面引入 HTTP 资源，从 HTTPS 页面跳到 HTTP 等）时不发送 Referrer 信息。这个规则是现在大部分浏览器默认所采用的<br>
                Origin Only：发送只包含 host 部分的 Referrer。启用这个规则，无论是否发生协议降级，无论是本站链接还是站外链接，都会发送 Referrer 信息，但是只包含协议 + host 部分（不包含具体的路径及参数等信息）<br>
                Origin When Cross-origin：仅在发生跨域访问时发送只包含 host 的 Referrer，同域下还是完整的。它与 Origin Only 的区别是多判断了是否 Cross-origin。需要注意的是协议、域名和端口都一致，才会被浏览器认为是同域<br>
                Unsafe URL：无论是否发生协议降级，无论是本站链接还是站外链接，统统都发送 Referrer 信息。正如其名，这是最宽松而最不安全的策略<br>
                </p>
            </section>
            <section>
                <p>
                    Response Headers:
                </p>
                <table style="font-size: 25px;text-align: center">
                <thead>
                    <tr>
                        <th>字段</th>
                        <th>说明</th>
                    </tr>
                </thead>
                <tbody>
                <tr>
                    <td>Cache-Control</td>
                    <td>告诉浏览器或者其他客户，什么环境可以安全地缓存文档</td>
                </tr>
                <tr>
                    <td>Connection</td>
                    <td>当client和server通信时对于长链接如何进行处理</td>
                </tr>
                <tr>
                    <td>Content-Encoding</td>
                    <td>数据在传输过程中所使用的压缩编码方式</td>
                </tr>
                <tr>
                    <td>Content-Type</td>
                    <td>数据的类型</td>
                </tr>
                <tr>
                    <td>Date</td>
                    <td>数据从服务器发送的时间</td>
                </tr>
                <tr>
                    <td>Expires</td>
                    <td>应该在什么时候认为文档已经过期，从而不再缓存它？</td>
                </tr>
                <tr>
                    <td>Server</td>
                    <td>服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置</td>
                </tr>
                <tr>
                    <td>Set-Cookie</td>
                    <td>设置和页面关联的cookie</td>
                </tr>
                <tr>
                    <td>Transfer-Encoding</td>
                    <td>数据传输的方式</td>
                </tr>
                </tbody>
                </table>
            </section>
            <section>
                <p>
                    Request Headers:
                </p>
                <table style="font-size: 25px;text-align: center">
                    <thead>
                    <tr>
                        <th>字段</th>
                        <th>说明</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>Accept</td>
                        <td>表示浏览器支持的 MIME 类型</td>
                    </tr>
                    <tr>
                        <td>Accept-Encoding</td>
                        <td>浏览器支持的压缩类型
                        </td>
                    </tr>
                    <tr>
                        <td>Accept-Language</td>
                        <td>浏览器支持的语言类型，并且优先支持靠前的语言类型</td>
                    </tr>
                    <tr>
                        <td> Cache-Control</td>
                        <td>指定请求和响应遵循的缓存机制 </td>
                    </tr>
                    <tr>
                        <td> Connection</td>
                        <td> 当浏览器与服务器通信时对于长连接如何进行处理：close/keep-alive</td>
                    </tr>
                    <tr>
                        <td>Cookie</td>
                        <td>向服务器返回cookie，这些cookie是之前服务器发给浏览器的</td>
                    </tr>
                    <tr>
                        <td> Host</td>
                        <td> 请求的服务器URL</td>
                    </tr>
                    <tr>
                        <td>Referer</td>
                        <td>该页面的来源URL</td>
                    </tr>
                    <tr>
                        <td> User-Agent</td>
                        <td>用户客户端的一些必要信息</td>
                    </tr>
                    </tbody>
                </table>
                <p><a href=" http://www.cnblogs.com/xumengxuan/p/3761314.html" target="_blank">http协议报头详解</a></p>
            </section>
        </section>
        <section>
            <h3>3.常见问题</h3>
        </section>
        <section>
                <p>使用post发送请求时如何设置content-type的值</p>
        </section>
        <section>
            <h3>4.解决方案</h3>
        </section>
        <section>
            <p style="text-align: left;font-size: 30px">协议规定 POST 提交的数据必须放在消息主体（entity-body）中，但协议并没有规定数据必须使用什么编码方式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。<br>
                但是，数据发送出去，还要服务端解析成功才有意义。一般服务端语言如 php、python 等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type
                字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。所以说到 POST 提交数据方案，包含了 Content-Type 和消息主体编码方式两部分。</p>
        </section>
        <section>
            <p style="text-align: left">
                1. application/x-www-form-urlencoded 最常见的POST提交格式，使用这个编码格式post的数据会以键值对的方式提交。<br>
                2. multipart/form-data 通常上传图片等文件会使用这种编码格式提交。<br>
                3. application/json 提交JSON格式的数据。<br>
                4. text/plain 窗体数据以纯文本形式进行编码，其中不含任何控件或格式字符。
            </p>
            <pre>
                <code>
headers: {'Content-Type': 'application/x-www-form-urlencoded'}
                </code>
            </pre>
        </section>
        <section>
            <p style="text-align: left;font-size: 30px">
                当action为get时候，浏览器用x-www-form-urlencoded的编码方式把form数据转换成一个字串（name1=value1&name2=value2...），然后把这个字串append到url后面，用?分割，加载这个新的url。 <br>
                当action为post时候，浏览器把form数据封装到http body中，然后发送到server。 如果没有type=file的控件，用默认的application/x-www-form-urlencoded就可以了。 但是如果有type=file的话，就要用到multipart/form-data了。浏览器会把整个表单以控件为单位分割，并为每个部分加上Content-Disposition(form-data或者file),Content-Type(默认为text/plain),name(控件name)等信息，并加上分割符(boundary)。
            </p>
        </section>
        <section>
            <h3>5.编码实战</h3>
        </section>
        <section>
            此知识点暂无编码，主要在于学会查看network中的信息。
            <!--<pre>-->
                <!--<code>-->
                <!--console.log("Hello World");-->
                <!--alert("Hello PTT");-->
                <!--</code>-->
            <!--</pre>-->
        </section>
        <section>
            <h3>6.扩展思考</h3>
        </section>
        <section>
            <p>除了已经提到过的，content-type还有那些类型</p>
            <p><a href="http://tools.jb51.net/table/http_content_type">HTTP Content-type 对照表</a></p>
        </section>
        <section>
            <h3>7.参考文献</h3>
        </section>
        <section>
            <p>参考一：<a href="https://imququ.com/post/referrer-policy.html" target="_blank">Referrer Policy 介绍</a></p>
            <p>参考二：<a href="http://www.cnblogs.com/LibraThinker/p/5981346.html" target="_blank">Network面板</a></p>
            <p>参考三：<a href=" http://www.cnblogs.com/xumengxuan/p/3761314.html" target="_blank">http协议报头详解</a></p>
        </section>
        <section>
            <h3>8.更多讨论</h3>
        </section>
        <section>
            <p>
                时间轴中的不同颜色的线代表什么意思？
            </p>
        </section>
        <section>
            <p style="font-size: 25px;text-align: left">
                Queueing:请求文件顺序的的排序。
                <br>
                Stalled:是浏览器得到要发出这个请求的指令到请求可以发出的等待时间，一般是代理协商、以及等待可复用的TCP连接释放的时间，不包括DNS查询、建立TCP连接等时间等。
                <br>
                Proxy negotiation：浏览器使用代理服务器协商请求的时间
                <br>
                DNS Lookup:时间执行DNS查找。每个新域pagerequires DNS查找一个完整的往返。 DNS查询的时间，当本地DNS缓存没有的时候，这个时间可能是有一段长度的，但是比如你一旦在host中设置了DNS，或者第二次访问，由于浏览器的DNS缓存还在，这个时间就为0了。
                <br>
                Initial connection:建立TCP连接的时间，就相当于客户端从发请求开始到TCP握手结束这一段，包括DNS查询+Proxy时间+TCP握手时间。
                <br>
                Request sent:请求第一个字节发出前到最后一个字节发出后的时间，也就是上传时间。
                <br>
                Waiting(TTFB):请求发出后，到收到响应的第一个字节所花费的时间(Time To First Byte),发送请求完毕到接收请求开始的时间;这个时间段就代表服务器处理和返回数据网络延时时间了。服务器优化的目的就是要让这个时间段尽可能短。
                <br>
                Content Download:收到响应的第一个字节，到接受完最后一个字节的时间，就是下载时间。
            </p>
        </section>
        <section>
            <h4>鸣谢</h4>
            <p>感谢大家观看</p>
            <p><small>BY : 周启明 | 朱芳山</small></p>
        </section>

    </div>
</div>

<script src="../lib/reveal/js/head.min.js"></script>
<script src="../lib/reveal/reveal.js"></script>

<script>

    // 以下为常见配置属性的默认值
    // {
    // 	controls: true, // 是否在右下角展示控制条
    // 	progress: true, // 是否显示演示的进度条
    // 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
    // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
    // 	keyboard: true, // 是否启用键盘快捷键来导航
    // 	overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
    // 	center: true, // 是否将幻灯片垂直居中
    // 	touch: true, // 是否在触屏设备上启用触摸滑动切换
    // 	loop: false, // 是否循环演示
    // 	rtl: false, // 是否将演示的方向变成RTL，即从右往左
    // 	fragments: true, // 全局开启和关闭碎片。
    // 	autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
    // 	transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
    // 	transitionSpeed: 'default', // 过渡速度，default/fast/slow
    // 	mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
    // }

    // 初始化幻灯片
    Reveal.initialize({
        history: true,
        dependencies: [
            { src: '../plugin/markdown/marked.js' },
            { src: '../plugin/markdown/markdown.js' },
            { src: '../plugin/notes/notes.js', async: true },
            { src: '../plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
    });
</script>
</body>
</html>
